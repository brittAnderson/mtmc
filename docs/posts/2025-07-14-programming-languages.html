<!doctype html>
<html lang="en">
    <head>
        <meta charset="utf-8">
        <meta http-equiv="x-ua-compatible" content="ie=edge">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <title>Mind→Theory→Math→Code</title>
        <link rel="stylesheet" href="../css/default.css" />
    </head>
    <body>
        <header>
            <div class="logo">
                <a href="../">Mind→Theory→Math→Code </a>
            </div>
            <nav>
                <a href="../">Home</a>
                <a href="../about.html">About</a>
                <a href="../contact.html">Contact</a>
                <a href="../archive.html">Archive</a>
            </nav>
        </header>

        <main role="main">
            <h1>Can Programming Languages Tell Us How We Think?</h1>
            <article>
    <section class="header">
        Posted on July 14, 2025
        
            by Britt Anderson
        
    </section>
    <section>
        <h1 id="programming-language-features-that-cognitive-modelers-dont-seem-to-talk-about">Programming Language Features that Cognitive Modelers Don't Seem to Talk About</h1>
<p>Our cognition is structured. Our spoken languages follow rules, some of
which seem to be universal. Since the same minds that speak, and are
thus constrained, are the ones that designed our programming languages
can we infer anything about how our minds might work from the features
language designers discover and create? Could a recognition of the
relevance lead us to make better choices in the programming language we
choose to implement a cognitive model?</p>
<ol type="1">
<li><p>Are our minds lazy? Most of our programming languages use "eager"
evaluation, but some, e.g. Haskell, use "lazy" evaluation. For
example in Haskell I can create a lazy list.</p>
<div class="captioned-content">
<div class="caption">
<p>The list is infinite, but Haskell is lazy and only generates what is
necessary. Since I only asked for the first 11 elements, that is all
it computes. The rest is a sort of promise. Some refer to this as
<code>call-by-need</code> as opposed to <code>call-by-value</code>.</p>
</div>
<div class="sourceCode" id="aLazyList" data-results="value" data-exports="both"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="aLazyList-1"><a href="#aLazyList-1" aria-hidden="true" tabindex="-1"></a><span class="ot">myil ::</span> [<span class="dt">Int</span>]</span>
<span id="aLazyList-2"><a href="#aLazyList-2" aria-hidden="true" tabindex="-1"></a>myil <span class="ot">=</span> [<span class="dv">1</span><span class="op">..</span>]</span>
<span id="aLazyList-3"><a href="#aLazyList-3" aria-hidden="true" tabindex="-1"></a><span class="fu">take</span> <span class="dv">11</span> myil</span></code></pre></div>
</div></li>
</ol>
<table>
<tbody>
<tr>
<td style="text-align: left;">1</td>
<td style="text-align: left;">2</td>
<td style="text-align: left;">3</td>
<td style="text-align: left;">4</td>
<td style="text-align: left;">5</td>
<td style="text-align: left;">6</td>
<td style="text-align: left;">7</td>
<td style="text-align: left;">8</td>
<td style="text-align: left;">9</td>
<td style="text-align: left;">10</td>
<td style="text-align: left;">11</td>
</tr>
</tbody>
</table>
<p>Maybe we can think of infinity without being able to count to it,
because infinity exists as a promise. We can describe how to get there
and that is good enough.</p>
<ol type="1">
<li><p>Do our thoughts have types? Programming languages have "types." A
value can be an interger or a floating point value. It can be a
character or a string. We can have lists of integers, and we for
some languages we can define our own potentially very exotic types.
This allows the infrastructure of our programming language, the
interpreters and compilers and such, to operate on our input. We can
use the types to determine what to do and even overload our
operators.</p>
<div class="captioned-content">
<div class="caption">
<p>The same operator <code class="verbatim">+</code> will add two numbers but
concatenate two strings. They <code>types</code> of the values let it know what
to do.</p>
</div>
<div class="sourceCode" id="Simple_Python_Types" data-results="output" data-exports="both"><pre class="sourceCode python"><code class="sourceCode python"><span id="Simple_Python_Types-1"><a href="#Simple_Python_Types-1" aria-hidden="true" tabindex="-1"></a>string1 <span class="op">=</span> <span class="st">&quot;hello &quot;</span></span>
<span id="Simple_Python_Types-2"><a href="#Simple_Python_Types-2" aria-hidden="true" tabindex="-1"></a>string2 <span class="op">=</span> <span class="st">&quot;world&quot;</span></span>
<span id="Simple_Python_Types-3"><a href="#Simple_Python_Types-3" aria-hidden="true" tabindex="-1"></a>num1 <span class="op">=</span> <span class="dv">1</span></span>
<span id="Simple_Python_Types-4"><a href="#Simple_Python_Types-4" aria-hidden="true" tabindex="-1"></a>num2 <span class="op">=</span> <span class="dv">2</span></span>
<span id="Simple_Python_Types-5"><a href="#Simple_Python_Types-5" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span> (num1 <span class="op">+</span> num2)</span>
<span id="Simple_Python_Types-6"><a href="#Simple_Python_Types-6" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span> (string1 <span class="op">+</span> string2)</span></code></pre></div>
</div>
<pre class="example"><code>3
hello world</code></pre>
<p>Does this notion of a "type" exist for our thoughts? At the neural
level spikes are on or off, but the same is true of all the little
bits in our computers. Still, the language can superimpose a type on
these 0/1 patterns. Does our mentalese do the same?</p></li>
<li><p>Are our types of thoughts static or dynamic?</p>
<div class="captioned-content">
<div class="caption">
<p>Our variable <code>a</code> is initially a character. Then it is defined to be
a number. The type of <code>a</code> is altered dynamically.</p>
</div>
<div class="sourceCode" id="Dynamic_Typing" data-exports="both" data-results="output"><pre class="sourceCode python"><code class="sourceCode python"><span id="Dynamic_Typing-1"><a href="#Dynamic_Typing-1" aria-hidden="true" tabindex="-1"></a>a <span class="op">=</span> <span class="st">&quot;1&quot;</span></span>
<span id="Dynamic_Typing-2"><a href="#Dynamic_Typing-2" aria-hidden="true" tabindex="-1"></a>a <span class="op">=</span> <span class="dv">1</span></span>
<span id="Dynamic_Typing-3"><a href="#Dynamic_Typing-3" aria-hidden="true" tabindex="-1"></a>b <span class="op">=</span> <span class="dv">2</span></span>
<span id="Dynamic_Typing-4"><a href="#Dynamic_Typing-4" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span> (a <span class="op">+</span> b)</span></code></pre></div>
</div>
<pre class="example"><code>3</code></pre>
<div class="captioned-content">
<div class="caption">
<p>Trying to force our previously defined integer to be a string
produces an error in Haskell.</p>
</div>
<div class="sourceCode" id="staticTyping" data-results="output" data-exports="both"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="staticTyping-1"><a href="#staticTyping-1" aria-hidden="true" tabindex="-1"></a><span class="op">:</span>set <span class="op">-</span><span class="dt">Wall</span></span>
<span id="staticTyping-2"><a href="#staticTyping-2" aria-hidden="true" tabindex="-1"></a><span class="ot">x ::</span> <span class="dt">Int</span></span>
<span id="staticTyping-3"><a href="#staticTyping-3" aria-hidden="true" tabindex="-1"></a>x <span class="ot">=</span> <span class="dv">42</span></span>
<span id="staticTyping-4"><a href="#staticTyping-4" aria-hidden="true" tabindex="-1"></a>x <span class="ot">=</span> <span class="st">&quot;hello&quot;</span></span></code></pre></div>
</div>
<pre class="example"><code>&lt;interactive&gt;:4:1: error: [GHC-88464]
    Variable not in scope: x :: Int
&lt;interactive&gt;:6:1: warning: [GHC-63397] [-Wname-shadowing]
    This binding for ‘x’ shadows the existing binding
      defined at &lt;interactive&gt;:5:1</code></pre>
<p>When you learn a fact is it fixed? Can paradoxes of thought be
brought to the level of static typing?</p></li>
<li><p>Are our minds interpreted, compiled or a life long image?
Interpreted languages read the code line by line and give a
simultaneous translation. Compiled languages digest an entire
program at once and output the machine code translation. Images are
"live" and execute and re-define on the fly. Python is typically
interpreted. Haskell compiled. Common Lisp is an image.</p>
<p>Anecdotes abound about problems being solved after a good night's
sleep. Is the replay of our dreams the compilation of our
experiences? Is the real time response to environmental events the
interpretation of input? Is the constant revision of our lived
experience best accomodated by the metaphor of the <a href="https://arxiv.org/abs/2110.08993">Lisp
Image</a>?</p></li>
<li><p>Do our minds engage in metaprogramming?</p>
<div class="captioned-content">
<div class="caption">
<p>In some programming languages you can write code that writes code.
This is best known for Common Lisp, but exists for other languages
too, e.g. Lean, Julia, and Template Haskell.</p>
</div>
<div class="sourceCode" id="metaprogramming" data-org-language="lisp" data-results="output"><pre class="sourceCode commonlisp"><code class="sourceCode commonlisp"><span id="metaprogramming-1"><a href="#metaprogramming-1" aria-hidden="true" tabindex="-1"></a><span class="co">;; Define a simple conditional macro</span></span>
<span id="metaprogramming-2"><a href="#metaprogramming-2" aria-hidden="true" tabindex="-1"></a>(<span class="kw">defmacro</span><span class="fu"> unless-zero </span>(<span class="kw">number</span> &amp;body body)</span>
<span id="metaprogramming-3"><a href="#metaprogramming-3" aria-hidden="true" tabindex="-1"></a>  `(<span class="kw">unless</span> (<span class="op">=</span> ,<span class="kw">number</span> <span class="dv">0</span>)</span>
<span id="metaprogramming-4"><a href="#metaprogramming-4" aria-hidden="true" tabindex="-1"></a>     ,@body))</span>
<span id="metaprogramming-5"><a href="#metaprogramming-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="metaprogramming-6"><a href="#metaprogramming-6" aria-hidden="true" tabindex="-1"></a><span class="co">;; Test the macro</span></span>
<span id="metaprogramming-7"><a href="#metaprogramming-7" aria-hidden="true" tabindex="-1"></a>(unless-zero <span class="dv">5</span></span>
<span id="metaprogramming-8"><a href="#metaprogramming-8" aria-hidden="true" tabindex="-1"></a>  (<span class="kw">format</span> <span class="kw">t</span> <span class="st">&quot;Number is not zero!~%&quot;</span>)</span>
<span id="metaprogramming-9"><a href="#metaprogramming-9" aria-hidden="true" tabindex="-1"></a>  (<span class="kw">format</span> <span class="kw">t</span> <span class="st">&quot;Its square is: ~a~%&quot;</span> (<span class="op">*</span> <span class="dv">5</span> <span class="dv">5</span>)))</span>
<span id="metaprogramming-10"><a href="#metaprogramming-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="metaprogramming-11"><a href="#metaprogramming-11" aria-hidden="true" tabindex="-1"></a>(unless-zero <span class="dv">0</span></span>
<span id="metaprogramming-12"><a href="#metaprogramming-12" aria-hidden="true" tabindex="-1"></a>  (<span class="kw">format</span> <span class="kw">t</span> <span class="st">&quot;You don't know nothing&quot;</span>))</span>
<span id="metaprogramming-13"><a href="#metaprogramming-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="metaprogramming-14"><a href="#metaprogramming-14" aria-hidden="true" tabindex="-1"></a>(unless-zero <span class="dv">1</span></span>
<span id="metaprogramming-15"><a href="#metaprogramming-15" aria-hidden="true" tabindex="-1"></a>  (<span class="kw">format</span> <span class="kw">t</span> <span class="st">&quot;Number is one!~%&quot;</span>))</span></code></pre></div>
</div>
<pre class="example"><code>Number is not zero!
Its square is: 25
Number is one!</code></pre>
<p>We learn many things as we grow and age, and some of those things
are not simply re-definitions, but deep conceptual changes. How is
it we learn to learn? How can we reprogram ourselves? Is the concept
of the metaprogram one we need for any satisfactory account of
thinking?</p></li>
</ol>
<h1 id="in-summary">In summary,</h1>
<p>Maybe we should think more about what the designers of programming
languages have created when thinking about how to model the thinking
that we do. Maybe thinking about the features of the cognitive process
we are modelling will lead us to favor some programming language over
others as it permits a more natural application of our ideas to the
problem.</p>
    </section>
</article>

        </main>

        <footer>
	  <a href="../rss.xml">RSS</a>
        </footer>
    </body>
</html>
